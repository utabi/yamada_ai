<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>粘菌型自己組織化シミュレーション</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 20px;
            margin: 0;
        }
        
        #container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        #controls {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #0f0;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 15px;
            margin-right: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        #display {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .view {
            flex: 1;
        }
        
        .view-title {
            color: #ff0;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .grid-display {
            line-height: 1.0;
            font-size: 12px;
            white-space: pre;
            background: #111;
            padding: 10px;
            border: 1px solid #333;
            font-family: 'Courier New', monospace;
        }
        
        #stats {
            border: 1px solid #0f0;
            padding: 10px;
        }
        
        /* 色の定義 */
        .wall { color: #666; }
        .empty { color: #111; }
        .food { color: #f00; }
        .core { color: #ff0; background: #440; }
        .body-high { color: #fa0; }
        .body-med { color: #a80; }
        .body-low { color: #650; }
        .trail { color: #330; }
    </style>
</head>
<body>
    <div id="container">
        <h1>粘菌型自己組織化シミュレーション - 複数セルのアメーバ</h1>
        
        <div id="controls">
            <button onclick="toggleSimulation()">開始/停止</button>
            <button onclick="resetSimulation()">リセット</button>
            <button onclick="addFood()">餌を追加</button>
            <button onclick="addObstacle()">障害物を追加</button>
            速度: <input type="range" id="speed" min="50" max="500" value="100">
            粘性: <input type="range" id="viscosity" min="1" max="10" value="3">
            サイズ: <input type="range" id="slimeSize" min="5" max="30" value="8">
        </div>
        
        <div id="display">
            <div class="view">
                <div class="view-title">粘菌の動き（リアルタイム）</div>
                <div id="main-view" class="grid-display"></div>
            </div>
            <div class="view">
                <div class="view-title">化学物質濃度マップ</div>
                <div id="chemical-view" class="grid-display"></div>
            </div>
            <div class="view">
                <div class="view-title">流れ場（セルの移動方向）</div>
                <div id="flow-view" class="grid-display"></div>
            </div>
        </div>
        
        <div id="stats">
            <div>ステップ: <span id="steps">0</span></div>
            <div>セル数: <span id="cellCount">0</span></div>
            <div>重心位置: <span id="centerMass">(0, 0)</span></div>
            <div>集合度: <span id="cohesion">0.00</span></div>
            <div>活性度: <span id="activity">0.00</span></div>
            <div>餌獲得数: <span id="foodEaten">0</span></div>
            <div>形状: <span id="shape">初期化中</span></div>
        </div>
    </div>
    
    <script>
        // グリッドサイズ
        const GRID_WIDTH = 60;
        const GRID_HEIGHT = 30;
        
        // セルの状態
        const CELL_EMPTY = 0;
        const CELL_SLIME = 1;
        const CELL_WALL = 2;
        const CELL_FOOD = 3;
        
        // 粘菌セル
        class SlimeCell {
            constructor(x, y, energy = 1.0) {
                this.x = x;
                this.y = y;
                this.energy = energy;
                this.age = 0;
                this.vx = 0;  // 速度
                this.vy = 0;
                this.isCore = false;  // コアセルかどうか
            }
            
            update(grid, chemical, flow) {
                this.age++;
                
                // エネルギー減衰（もっとゆっくり）
                this.energy *= 0.995;
                
                // 境界チェック
                if (this.y < 0 || this.y >= GRID_HEIGHT || this.x < 0 || this.x >= GRID_WIDTH) {
                    this.x = Math.max(0, Math.min(GRID_WIDTH - 1, this.x));
                    this.y = Math.max(0, Math.min(GRID_HEIGHT - 1, this.y));
                    return;
                }
                
                // 化学物質に引き寄せられる
                const gradient = this.getChemicalGradient(chemical);
                
                // 流れ場の影響
                const flowForce = flow[this.y] && flow[this.y][this.x] ? flow[this.y][this.x] : {x: 0, y: 0};
                
                // 速度更新（もっと活発に）
                this.vx = this.vx * 0.7 + gradient.x * 0.4 + flowForce.x * 0.3 + (Math.random() - 0.5) * 0.1;
                this.vy = this.vy * 0.7 + gradient.y * 0.4 + flowForce.y * 0.3 + (Math.random() - 0.5) * 0.1;
                
                // 速度制限
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 0.5) {
                    this.vx = this.vx / speed * 0.5;
                    this.vy = this.vy / speed * 0.5;
                }
            }
            
            getChemicalGradient(chemical) {
                let maxGrad = { x: 0, y: 0 };
                let maxDiff = 0;
                
                // 境界チェック
                if (!chemical[this.y] || !chemical[this.y][this.x]) {
                    return maxGrad;
                }
                
                const current = chemical[this.y][this.x];
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = this.x + dx;
                        const ny = this.y + dy;
                        
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            const diff = chemical[ny][nx] - current;
                            if (diff > maxDiff) {
                                maxDiff = diff;
                                maxGrad = { x: dx, y: dy };
                            }
                        }
                    }
                }
                
                return maxGrad;
            }
        }
        
        // 粘菌コロニー
        class SlimeMold {
            constructor() {
                this.cells = [];
                this.grid = this.createGrid();
                this.chemical = this.createGrid();  // 化学物質濃度
                this.flow = this.createFlowField();  // 流れ場
                this.trail = this.createGrid();  // 軌跡
                this.foodEaten = 0;
                this.steps = 0;
                
                // 初期配置
                this.initializeCells();
                this.addRandomFood();
                this.addRandomWalls();
            }
            
            createGrid() {
                return Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
            }
            
            createFlowField() {
                return Array(GRID_HEIGHT).fill().map(() => 
                    Array(GRID_WIDTH).fill().map(() => ({ x: 0, y: 0 }))
                );
            }
            
            initializeCells() {
                const size = parseInt(document.getElementById('slimeSize').value);
                
                // ランダムな位置に散らばって配置
                for (let i = 0; i < size; i++) {
                    // 画面のランダムな位置
                    const x = 10 + Math.random() * (GRID_WIDTH - 20);
                    const y = 5 + Math.random() * (GRID_HEIGHT - 10);
                    
                    if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                        const cell = new SlimeCell(x, y, 0.8 + Math.random() * 0.2);
                        // コアセルは作らない（全て平等）
                        this.cells.push(cell);
                    }
                }
            }
            
            addRandomFood() {
                for (let i = 0; i < 5; i++) {
                    const x = Math.floor(Math.random() * GRID_WIDTH);
                    const y = Math.floor(Math.random() * GRID_HEIGHT);
                    this.grid[y][x] = CELL_FOOD;
                }
            }
            
            addRandomWalls() {
                // ランダムな障害物を配置
                for (let i = 0; i < 3; i++) {
                    const x = Math.floor(Math.random() * (GRID_WIDTH - 10)) + 5;
                    const y = Math.floor(Math.random() * (GRID_HEIGHT - 10)) + 5;
                    const w = Math.floor(Math.random() * 5) + 3;
                    const h = Math.floor(Math.random() * 5) + 3;
                    
                    for (let dx = 0; dx < w; dx++) {
                        for (let dy = 0; dy < h; dy++) {
                            if (x + dx < GRID_WIDTH && y + dy < GRID_HEIGHT) {
                                this.grid[y + dy][x + dx] = CELL_WALL;
                            }
                        }
                    }
                }
            }
            
            update() {
                this.steps++;
                const viscosity = parseInt(document.getElementById('viscosity').value) / 10;
                
                // グリッドをクリア
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (this.grid[y][x] === CELL_SLIME) {
                            this.grid[y][x] = CELL_EMPTY;
                        }
                        // 軌跡の減衰
                        this.trail[y][x] *= 0.95;
                    }
                }
                
                // 化学物質の拡散と減衰
                this.diffuseChemical();
                
                // 流れ場の更新
                this.updateFlowField();
                
                // セルの相互作用計算
                const forces = this.calculateForces();
                
                // セルの移動と更新
                const newCells = [];
                for (let i = 0; i < this.cells.length; i++) {
                    const cell = this.cells[i];
                    const force = forces[i];
                    
                    // 力を適用
                    cell.vx += force.x * (1 - viscosity);
                    cell.vy += force.y * (1 - viscosity);
                    
                    // セルの更新
                    cell.update(this.grid, this.chemical, this.flow);
                    
                    // 新しい位置を計算（浮動小数点のまま保持）
                    let newX = cell.x + cell.vx;
                    let newY = cell.y + cell.vy;
                    
                    // 境界チェック
                    newX = Math.max(0, Math.min(GRID_WIDTH - 1, newX));
                    newY = Math.max(0, Math.min(GRID_HEIGHT - 1, newY));
                    
                    // 壁チェック（整数座標で確認）
                    const gridX = Math.round(newX);
                    const gridY = Math.round(newY);
                    if (gridY >= 0 && gridY < GRID_HEIGHT && gridX >= 0 && gridX < GRID_WIDTH &&
                        this.grid[gridY][gridX] !== CELL_WALL) {
                        cell.x = newX;
                        cell.y = newY;
                        
                        // 餌を食べる
                        if (this.grid[gridY][gridX] === CELL_FOOD) {
                            cell.energy = Math.min(1.0, cell.energy + 0.5);  // もっとエネルギーを得る
                            this.foodEaten++;
                            // 化学物質を放出
                            this.chemical[gridY][gridX] += 5;
                            // 餌を消費
                            this.grid[gridY][gridX] = CELL_EMPTY;
                        }
                    }
                    
                    // 軌跡を残す（整数座標で）
                    const trailY = Math.round(cell.y);
                    const trailX = Math.round(cell.x);
                    if (trailY >= 0 && trailY < GRID_HEIGHT && trailX >= 0 && trailX < GRID_WIDTH) {
                        this.trail[trailY][trailX] = Math.min(1, this.trail[trailY][trailX] + 0.2);
                        // グリッドに配置
                        this.grid[trailY][trailX] = CELL_SLIME;
                    }
                    
                    // エネルギーがある細胞だけ生存
                    if (cell.energy > 0.1) {
                        newCells.push(cell);
                    }
                    
                    // 分裂（エネルギーが高い時、もっと頻繁に）
                    if (cell.energy > 0.8 && Math.random() < 0.15 && this.cells.length < 50) {
                        const angle = Math.random() * Math.PI * 2;
                        const newCell = new SlimeCell(
                            cell.x + Math.cos(angle),
                            cell.y + Math.sin(angle),
                            cell.energy * 0.5
                        );
                        cell.energy *= 0.5;
                        newCells.push(newCell);
                    }
                }
                
                this.cells = newCells;
                
                // 餌の自動補充（もっと頻繁に）
                if (Math.random() < 0.05) {
                    this.addFood();
                }
                
                // セルが少なくなったら補充
                if (this.cells.length < 5) {
                    this.initializeCells();
                }
            }
            
            calculateForces() {
                const forces = [];
                
                for (let i = 0; i < this.cells.length; i++) {
                    const cell = this.cells[i];
                    let fx = 0, fy = 0;
                    
                    // 他のセルとの相互作用
                    for (let j = 0; j < this.cells.length; j++) {
                        if (i === j) continue;
                        
                        const other = this.cells[j];
                        const dx = other.x - cell.x;
                        const dy = other.y - cell.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 0.1) continue;
                        
                        // 近距離：反発（強め）
                        if (dist < 1.5) {
                            fx -= dx / (dist * dist) * 0.8;
                            fy -= dy / (dist * dist) * 0.8;
                        }
                        // 中距離：適度な距離を保つ
                        else if (dist < 4) {
                            // 理想的な距離は2.5
                            const idealDist = 2.5;
                            const factor = (dist - idealDist) / idealDist;
                            fx += dx / dist * factor * 0.2;
                            fy += dy / dist * factor * 0.2;
                        }
                        // 遠距離：弱い引力
                        else if (dist < 8) {
                            fx += dx / dist * 0.05;
                            fy += dy / dist * 0.05;
                        }
                    }
                    
                    // 餌への誘引（化学物質とは別に直接的な引力も追加）
                    for (let fy2 = 0; fy2 < GRID_HEIGHT; fy2++) {
                        for (let fx2 = 0; fx2 < GRID_WIDTH; fx2++) {
                            if (this.grid[fy2][fx2] === CELL_FOOD) {
                                const dx = fx2 - cell.x;
                                const dy = fy2 - cell.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 15 && dist > 0.1) {
                                    // 餌への引力
                                    fx += (dx / dist) * (1 / (dist * 0.3));
                                    fy += (dy / dist) * (1 / (dist * 0.3));
                                }
                            }
                        }
                    }
                    
                    forces.push({ x: fx, y: fy });
                }
                
                return forces;
            }
            
            diffuseChemical() {
                const newChemical = this.createGrid();
                
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        let sum = 0;
                        let count = 0;
                        
                        // 周囲8セルから拡散
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                    sum += this.chemical[ny][nx];
                                    count++;
                                }
                            }
                        }
                        
                        // 拡散と減衰
                        newChemical[y][x] = (sum / count) * 0.9;
                        
                        // 餌から化学物質が出る
                        if (this.grid[y][x] === CELL_FOOD) {
                            newChemical[y][x] += 1;
                        }
                    }
                }
                
                this.chemical = newChemical;
            }
            
            updateFlowField() {
                // 餌への流れ場を生成
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        let totalX = 0, totalY = 0;
                        let hasFood = false;
                        
                        // 近くの餌を探す
                        for (let fy = 0; fy < GRID_HEIGHT; fy++) {
                            for (let fx = 0; fx < GRID_WIDTH; fx++) {
                                if (this.grid[fy][fx] === CELL_FOOD) {
                                    const dx = fx - x;
                                    const dy = fy - y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < 20 && dist > 0.1) {
                                        // 餌への流れ
                                        totalX += (dx / dist) * (1 / (dist + 1));
                                        totalY += (dy / dist) * (1 / (dist + 1));
                                        hasFood = true;
                                    }
                                }
                            }
                        }
                        
                        if (hasFood) {
                            const mag = Math.sqrt(totalX * totalX + totalY * totalY);
                            if (mag > 0) {
                                this.flow[y][x] = {
                                    x: (totalX / mag) * 0.2,
                                    y: (totalY / mag) * 0.2
                                };
                            } else {
                                this.flow[y][x] = { x: 0, y: 0 };
                            }
                        } else {
                            // 餌がない場合はランダムな探索
                            this.flow[y][x] = {
                                x: (Math.random() - 0.5) * 0.1,
                                y: (Math.random() - 0.5) * 0.1
                            };
                        }
                    }
                }
            }
            
            getCenterOfMass() {
                if (this.cells.length === 0) return { x: GRID_WIDTH / 2, y: GRID_HEIGHT / 2 };
                
                let sumX = 0, sumY = 0;
                for (let cell of this.cells) {
                    sumX += cell.x;
                    sumY += cell.y;
                }
                
                return {
                    x: sumX / this.cells.length,
                    y: sumY / this.cells.length
                };
            }
            
            getCohesion() {
                if (this.cells.length < 2) return 0;
                
                const center = this.getCenterOfMass();
                let sumDist = 0;
                
                for (let cell of this.cells) {
                    const dx = cell.x - center.x;
                    const dy = cell.y - center.y;
                    sumDist += Math.sqrt(dx * dx + dy * dy);
                }
                
                const avgDist = sumDist / this.cells.length;
                return Math.max(0, 1 - avgDist / 20);
            }
            
            getActivity() {
                let sumSpeed = 0;
                for (let cell of this.cells) {
                    sumSpeed += Math.sqrt(cell.vx * cell.vx + cell.vy * cell.vy);
                }
                return this.cells.length > 0 ? sumSpeed / this.cells.length : 0;
            }
            
            getShape() {
                const cohesion = this.getCohesion();
                const activity = this.getActivity();
                
                if (cohesion > 0.8) return "密集";
                if (cohesion > 0.5) return "集合";
                if (cohesion > 0.3) return "拡散";
                if (activity > 0.3) return "探索中";
                return "散在";
            }
            
            addFood() {
                const x = Math.floor(Math.random() * GRID_WIDTH);
                const y = Math.floor(Math.random() * GRID_HEIGHT);
                if (this.grid[y][x] === CELL_EMPTY) {
                    this.grid[y][x] = CELL_FOOD;
                }
            }
            
            addObstacle() {
                const x = Math.floor(Math.random() * (GRID_WIDTH - 5));
                const y = Math.floor(Math.random() * (GRID_HEIGHT - 5));
                for (let dx = 0; dx < 5; dx++) {
                    this.grid[y][x + dx] = CELL_WALL;
                }
            }
            
            render() {
                // メインビュー
                let mainView = '';
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const cell = this.cells.find(c => Math.round(c.x) === x && Math.round(c.y) === y);
                        
                        if (cell) {
                            if (cell.isCore) {
                                mainView += '<span class="core">◉</span>';
                            } else if (cell.energy > 0.7) {
                                mainView += '<span class="body-high">●</span>';
                            } else if (cell.energy > 0.4) {
                                mainView += '<span class="body-med">◐</span>';
                            } else {
                                mainView += '<span class="body-low">○</span>';
                            }
                        } else if (this.grid[y][x] === CELL_WALL) {
                            mainView += '<span class="wall">█</span>';
                        } else if (this.grid[y][x] === CELL_FOOD) {
                            mainView += '<span class="food">◆</span>';
                        } else if (this.trail[y][x] > 0.1) {
                            mainView += '<span class="trail">·</span>';
                        } else {
                            mainView += '<span class="empty">·</span>';
                        }
                    }
                    mainView += '\n';
                }
                document.getElementById('main-view').innerHTML = mainView;
                
                // 化学物質ビュー
                let chemicalView = '';
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const level = this.chemical[y][x];
                        
                        if (this.grid[y][x] === CELL_WALL) {
                            chemicalView += '<span class="wall">█</span>';
                        } else if (level > 0.8) {
                            chemicalView += '<span style="color: #f00">■</span>';
                        } else if (level > 0.5) {
                            chemicalView += '<span style="color: #f80">▓</span>';
                        } else if (level > 0.3) {
                            chemicalView += '<span style="color: #fc0">▒</span>';
                        } else if (level > 0.1) {
                            chemicalView += '<span style="color: #880">░</span>';
                        } else {
                            chemicalView += '<span class="empty">·</span>';
                        }
                    }
                    chemicalView += '\n';
                }
                document.getElementById('chemical-view').innerHTML = chemicalView;
                
                // 流れ場ビュー
                let flowView = '';
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (this.grid[y][x] === CELL_WALL) {
                            flowView += '<span class="wall">█</span>';
                        } else {
                            const flow = this.flow[y][x];
                            const angle = Math.atan2(flow.y, flow.x);
                            const strength = Math.sqrt(flow.x * flow.x + flow.y * flow.y);
                            
                            if (strength < 0.01) {
                                flowView += '<span class="empty">·</span>';
                            } else {
                                // 矢印で方向を表現
                                const arrows = ['→', '↗', '↑', '↖', '←', '↙', '↓', '↘'];
                                const index = Math.floor((angle + Math.PI) / (Math.PI * 2) * 8) % 8;
                                const color = strength > 0.05 ? '#ff0' : '#880';
                                flowView += `<span style="color: ${color}">${arrows[index]}</span>`;
                            }
                        }
                    }
                    flowView += '\n';
                }
                document.getElementById('flow-view').innerHTML = flowView;
                
                // 統計情報の更新
                const center = this.getCenterOfMass();
                document.getElementById('steps').textContent = this.steps;
                document.getElementById('cellCount').textContent = this.cells.length;
                document.getElementById('centerMass').textContent = `(${center.x.toFixed(1)}, ${center.y.toFixed(1)})`;
                document.getElementById('cohesion').textContent = this.getCohesion().toFixed(2);
                document.getElementById('activity').textContent = this.getActivity().toFixed(2);
                document.getElementById('foodEaten').textContent = this.foodEaten;
                document.getElementById('shape').textContent = this.getShape();
            }
        }
        
        // シミュレーション管理
        let slime = null;
        let running = false;
        let animationId = null;
        
        function init() {
            slime = new SlimeMold();
            slime.render();
        }
        
        function animate() {
            if (!running) return;
            
            slime.update();
            slime.render();
            
            const speed = parseInt(document.getElementById('speed').value);
            animationId = setTimeout(animate, speed);
        }
        
        function toggleSimulation() {
            running = !running;
            if (running) {
                animate();
            } else {
                clearTimeout(animationId);
            }
        }
        
        function resetSimulation() {
            running = false;
            clearTimeout(animationId);
            init();
        }
        
        function addFood() {
            if (slime) slime.addFood();
        }
        
        function addObstacle() {
            if (slime) slime.addObstacle();
        }
        
        // 初期化
        init();
    </script>
</body>
</html>