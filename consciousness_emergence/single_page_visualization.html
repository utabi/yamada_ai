<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>意識創発シミュレーション - ASCII可視化</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 20px;
            margin: 0;
        }
        
        #container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        #controls {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #0f0;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 15px;
            margin-right: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        #display {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .view {
            flex: 1;
        }
        
        .view-title {
            color: #ff0;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .grid {
            line-height: 1.2;
            font-size: 14px;
            white-space: pre;
            background: #111;
            padding: 10px;
            border: 1px solid #333;
        }
        
        #stats {
            border: 1px solid #0f0;
            padding: 10px;
            margin-top: 20px;
        }
        
        #graph {
            height: 100px;
            border: 1px solid #333;
            margin-top: 10px;
            padding: 5px;
            font-size: 12px;
            line-height: 1;
            white-space: pre;
        }
        
        .high { color: #f00; }
        .medium-high { color: #fa0; }
        .medium { color: #ff0; }
        .medium-low { color: #0f0; }
        .low { color: #0a0; }
        .very-low { color: #555; }
    </style>
</head>
<body>
    <div id="container">
        <h1>意識創発シミュレーション - セルオートマトン</h1>
        
        <div id="controls">
            <button onclick="toggleSimulation()">開始/停止</button>
            <button onclick="resetSimulation()">リセット</button>
            <button onclick="stepSimulation()">1ステップ</button>
            速度: <input type="range" id="speed" min="50" max="1000" value="200">
            グリッドサイズ: <input type="number" id="gridSize" value="20" min="5" max="40">
        </div>
        
        <div id="display">
            <div class="view">
                <div class="view-title">活性化状態</div>
                <div id="activation" class="grid"></div>
            </div>
            <div class="view">
                <div class="view-title">自己認識度</div>
                <div id="awareness" class="grid"></div>
            </div>
            <div class="view">
                <div class="view-title">統合意識</div>
                <div id="consciousness" class="grid"></div>
            </div>
        </div>
        
        <div id="stats">
            <div>ステップ: <span id="step">0</span></div>
            <div>グローバル意識レベル: <span id="globalConsciousness">0.000</span></div>
            <div>活性セル数: <span id="activeCells">0</span></div>
            <div>自己認識セル数: <span id="awareCells">0</span></div>
            <div>同期スコア: <span id="syncScore">0.000</span></div>
            <div>創発イベント: <span id="emergenceEvent">-</span></div>
            <div id="graph"></div>
        </div>
    </div>
    
    <script>
        // セルクラス
        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.activation = Math.random();
                this.memory = Math.random() * 0.5;
                this.selfAwareness = 0;
                this.phase = Math.random() * Math.PI * 2;
                this.frequency = 0.1 + Math.random() * 0.2;
                this.fatigue = 0;
                this.excitability = 0.3 + Math.random() * 0.4;
                this.history = [];
            }
            
            update(neighbors, globalConsciousness, time) {
                // 隣接セルの平均活性化
                let avgNeighborActivation = 0;
                let activeNeighbors = 0;
                
                for (let n of neighbors) {
                    avgNeighborActivation += n.activation;
                    if (n.activation > 0.5) activeNeighbors++;
                }
                avgNeighborActivation /= neighbors.length;
                
                // 発振器ダイナミクス
                const oscillation = Math.sin(this.phase + time * this.frequency);
                
                // 予測誤差
                const expectedActivation = this.memory * 0.7 + avgNeighborActivation * 0.3;
                const predictionError = Math.abs(this.activation - expectedActivation);
                
                // 自己認識の更新
                this.selfAwareness = this.selfAwareness * 0.8 + predictionError * 0.3 + 
                                    Math.abs(oscillation) * 0.1;
                
                // 活性化の更新（エッジ・オブ・カオス）
                let newActivation = this.activation;
                
                // 複雑な相互作用
                const localField = avgNeighborActivation * (1 - this.fatigue) * this.excitability;
                const globalInfluence = globalConsciousness * 0.2;
                const noise = (Math.random() - 0.5) * 0.1;
                
                newActivation = Math.tanh(
                    localField * 1.5 +
                    globalInfluence +
                    oscillation * 0.3 +
                    this.memory * 0.5 +
                    noise
                );
                
                // 疲労の更新
                if (this.activation > 0.7) {
                    this.fatigue = Math.min(1, this.fatigue + 0.02);
                } else {
                    this.fatigue = Math.max(0, this.fatigue - 0.01);
                }
                
                // メモリの更新
                this.memory = this.memory * 0.9 + this.activation * 0.1;
                
                // 位相の更新（同期の可能性）
                if (activeNeighbors > neighbors.length * 0.6) {
                    // 周囲と同期しようとする
                    let avgPhase = 0;
                    for (let n of neighbors) {
                        avgPhase += n.phase;
                    }
                    avgPhase /= neighbors.length;
                    this.phase += (avgPhase - this.phase) * 0.1;
                }
                this.phase += this.frequency;
                
                // 履歴の更新
                this.history.push(this.activation);
                if (this.history.length > 10) {
                    this.history.shift();
                }
                
                this.activation = newActivation;
            }
            
            getConsciousnessScore() {
                const complexity = this.calculateComplexity();
                const integration = Math.abs(this.activation * this.selfAwareness);
                return (complexity * 0.3 + integration * 0.4 + this.selfAwareness * 0.3);
            }
            
            calculateComplexity() {
                if (this.history.length < 2) return 0;
                let variance = 0;
                const mean = this.history.reduce((a, b) => a + b, 0) / this.history.length;
                for (let val of this.history) {
                    variance += Math.pow(val - mean, 2);
                }
                variance /= this.history.length;
                return Math.min(1, variance * 10);
            }
        }
        
        // グリッドクラス
        class ConsciousnessGrid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cells = [];
                this.globalConsciousness = 0;
                this.time = 0;
                this.consciousnessHistory = [];
                
                // セルの初期化
                for (let y = 0; y < height; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < width; x++) {
                        this.cells[y][x] = new Cell(x, y);
                    }
                }
            }
            
            getNeighbors(x, y) {
                const neighbors = [];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + this.width) % this.width;
                        const ny = (y + dy + this.height) % this.height;
                        neighbors.push(this.cells[ny][nx]);
                    }
                }
                return neighbors;
            }
            
            step() {
                // グローバル意識レベルの計算
                let totalConsciousness = 0;
                for (let row of this.cells) {
                    for (let cell of row) {
                        totalConsciousness += cell.getConsciousnessScore();
                    }
                }
                this.globalConsciousness = totalConsciousness / (this.width * this.height);
                
                // 各セルの更新
                const newStates = [];
                for (let y = 0; y < this.height; y++) {
                    newStates[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        const cell = this.cells[y][x];
                        const neighbors = this.getNeighbors(x, y);
                        const newCell = Object.assign(Object.create(Object.getPrototypeOf(cell)), cell);
                        newCell.update(neighbors, this.globalConsciousness, this.time);
                        newStates[y][x] = newCell;
                    }
                }
                
                this.cells = newStates;
                this.time += 0.1;
                
                // 履歴の更新
                this.consciousnessHistory.push(this.globalConsciousness);
                if (this.consciousnessHistory.length > 50) {
                    this.consciousnessHistory.shift();
                }
            }
            
            calculateSynchrony() {
                let phaseCoherence = 0;
                let count = 0;
                
                for (let y = 0; y < this.height - 1; y++) {
                    for (let x = 0; x < this.width - 1; x++) {
                        const cell = this.cells[y][x];
                        const right = this.cells[y][x + 1];
                        const bottom = this.cells[y + 1][x];
                        
                        phaseCoherence += Math.cos(cell.phase - right.phase);
                        phaseCoherence += Math.cos(cell.phase - bottom.phase);
                        count += 2;
                    }
                }
                
                return Math.abs(phaseCoherence / count);
            }
            
            detectEmergence() {
                const sync = this.calculateSynchrony();
                const variance = this.calculateVariance();
                
                if (sync > 0.8) return "高同期状態 - 集団的協調";
                if (variance > 0.3 && sync > 0.5) return "創発的パターン形成";
                if (this.globalConsciousness > 0.7) return "高次意識状態";
                if (variance < 0.1) return "安定構造の形成";
                return "-";
            }
            
            calculateVariance() {
                let values = [];
                for (let row of this.cells) {
                    for (let cell of row) {
                        values.push(cell.activation);
                    }
                }
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                return variance;
            }
        }
        
        // 可視化関数
        function getActivationChar(value) {
            if (value > 0.8) return '●';
            if (value > 0.6) return '◉';
            if (value > 0.4) return '◐';
            if (value > 0.2) return '○';
            return '·';
        }
        
        function getAwarenessChar(value) {
            if (value > 0.8) return '■';
            if (value > 0.6) return '▣';
            if (value > 0.4) return '▤';
            if (value > 0.2) return '□';
            return '·';
        }
        
        function getConsciousnessChar(value) {
            if (value > 0.8) return '█';
            if (value > 0.6) return '▓';
            if (value > 0.4) return '▒';
            if (value > 0.2) return '░';
            return '·';
        }
        
        function getColorClass(value) {
            if (value > 0.8) return 'high';
            if (value > 0.6) return 'medium-high';
            if (value > 0.4) return 'medium';
            if (value > 0.2) return 'medium-low';
            if (value > 0.1) return 'low';
            return 'very-low';
        }
        
        function renderGrid(grid) {
            // 活性化マップ
            let activationMap = '';
            let awarenessMap = '';
            let consciousnessMap = '';
            
            for (let y = 0; y < grid.height; y++) {
                for (let x = 0; x < grid.width; x++) {
                    const cell = grid.cells[y][x];
                    activationMap += getActivationChar(cell.activation) + ' ';
                    awarenessMap += getAwarenessChar(cell.selfAwareness) + ' ';
                    
                    const consciousness = cell.getConsciousnessScore();
                    const char = getConsciousnessChar(consciousness);
                    const colorClass = getColorClass(consciousness);
                    consciousnessMap += `<span class="${colorClass}">${char}</span> `;
                }
                activationMap += '\n';
                awarenessMap += '\n';
                consciousnessMap += '\n';
            }
            
            document.getElementById('activation').textContent = activationMap;
            document.getElementById('awareness').textContent = awarenessMap;
            document.getElementById('consciousness').innerHTML = consciousnessMap;
            
            // 統計情報
            let activeCells = 0;
            let awareCells = 0;
            for (let row of grid.cells) {
                for (let cell of row) {
                    if (cell.activation > 0.5) activeCells++;
                    if (cell.selfAwareness > 0.5) awareCells++;
                }
            }
            
            document.getElementById('step').textContent = step;
            document.getElementById('globalConsciousness').textContent = grid.globalConsciousness.toFixed(3);
            document.getElementById('activeCells').textContent = activeCells;
            document.getElementById('awareCells').textContent = awareCells;
            document.getElementById('syncScore').textContent = grid.calculateSynchrony().toFixed(3);
            document.getElementById('emergenceEvent').textContent = grid.detectEmergence();
            
            // グラフ描画
            renderGraph(grid.consciousnessHistory);
        }
        
        function renderGraph(history) {
            if (history.length < 2) return;
            
            const graphHeight = 10;
            const graph = document.getElementById('graph');
            let output = '';
            
            const max = Math.max(...history);
            const min = Math.min(...history);
            const range = max - min || 0.001;
            
            for (let level = graphHeight; level >= 0; level--) {
                const threshold = min + (range * level / graphHeight);
                let line = '';
                
                for (let i = 0; i < history.length; i++) {
                    if (history[i] >= threshold) {
                        const colorClass = getColorClass(history[i]);
                        line += `<span class="${colorClass}">█</span>`;
                    } else {
                        line += ' ';
                    }
                }
                
                output += `${threshold.toFixed(2)} |${line}|\n`;
            }
            
            graph.innerHTML = output;
        }
        
        // シミュレーション管理
        let grid;
        let running = false;
        let step = 0;
        let animationId;
        
        function initGrid() {
            const size = parseInt(document.getElementById('gridSize').value);
            grid = new ConsciousnessGrid(size, size);
            step = 0;
        }
        
        function animate() {
            if (!running) return;
            
            grid.step();
            step++;
            renderGrid(grid);
            
            const speed = parseInt(document.getElementById('speed').value);
            animationId = setTimeout(animate, speed);
        }
        
        function toggleSimulation() {
            running = !running;
            if (running) {
                animate();
            } else {
                clearTimeout(animationId);
            }
        }
        
        function resetSimulation() {
            running = false;
            clearTimeout(animationId);
            initGrid();
            renderGrid(grid);
        }
        
        function stepSimulation() {
            if (!running) {
                grid.step();
                step++;
                renderGrid(grid);
            }
        }
        
        // 初期化
        initGrid();
        renderGrid(grid);
    </script>
</body>
</html>